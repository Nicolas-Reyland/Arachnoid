# Arachnoid - Interpreterimport osimport sysimport psutilimport subprocessimport jsonimport timeimport base64import tracebackimport webbrowserfrom string import ascii_letters as alphabetfrom random import choicefrom glob import glob'''#TODO üêù : - sendfile: see if data received correctly. if not, resend until it has arrived uncorrupted. - sendfile backup system (~redo) - many other things -'''ENV_VARS = {			'ROOT DIR': os.getcwd(),			'VERBOSE': 0,			'SHELL VERSION': None,			'INTERPRETER VERSION': None,			'IN SHELL': 0,			'MAX BUFFER SIZE': 5120,			'DF WAIT TIME': 0,			'CORE FILES': ['arachnoid.py', 'use.py', 'interpreter.py', 'interpreterv2.py', 'shellv2.py'],			'SAFE MODE': 1,			}COMMAND_DICT = {'raw-out': [],			# raw-out: the sent commands (in order), as sent				'raw-run': [],			# raw-run: the commands that were ran (locally)				'raw-run-user': [],		# raw-run-user: the commands that were written by the user (no sub-calls)				'writefile-hist': {}	# history of sendfile, for corruption repair				}FILE_IN_PATH  = 'input.txt'FILE_OUT_PATH = 'output.txt'vprint = lambda *args: print(*args) if ENV_VARS['VERBOSE'] else Nonecommand_list = [	# A is the current instance of a Web/Spider. B is the other communicator.					# A sends the commands. B runs them					# if a command does not work/is kinda broken when using the a certain shell/interpreter version,					# the "->" is preceeded by a ("s1" || "s2") ||/&& ("i1" || "i2") ||/&& ("v1" || "v2")					# to show on which versions the command works					# arguments in [brackets] are optional/not needed				'run',						# run command 	 			-> B runs the command locally (as if B sent "command" to A)				'ping',						# ping 						-> B sends a msg if up				'shutdown',					# shutdown 					-> shutdown A & B				'restart',					# restart 			v1		-> restart A & B (does not work on shell/interpreter version 2)				'sync',						# sync 						-> sync the "CORE FILES" from ENV_VARS (Arachnoid projects core files) from A to B				'synci',					# synci 			v1		-> sync the interpreter.py file (this one) from A to B and restarts ("restart")				'sync+',					# sync+ 			v1		-> executes "sync" then "restart"				'cmd',						# cmd command 				-> B runs "command" in a shell (windowns -> cmd)				'shell-mode',				# shell-mode	broken		-> A gets a shell of B (broken)				'sendfile',					# sendfile path 			-> A send the file using path to B				'getfile',					# getfile path 				-> A requests B to send the file at the path				'sendfiles',				# sendfiles filter/list 	-> A sends all the files that correspond to the																		# unix-like file-filter of filter, or																		# a list of files given like this: "path-1" "path-2" ... "path-n"				'getfiles',					# getfiles filter/list 		-> B requests A to send all the files that correspond to the																		# unix-like file-filter of filter, or																		# a list of files given like this: "path-1" "path-2" ... "path-n"				'verb',						# verb [value]				-> set the VERBOSE value to value. if no argument is given,																		# it prints the vurrent VERBOSE value				'open-tab',					# open-tab url				-> open a chrome tab using url				'sync-chrome',				# sync-chrome 				-> sync all the tabs from A to B (Chrome only for now)				'cd',						# cd [dir]					-> change the directory to path.																		# the "~" is equal to the ENV_ARGS['ROOT DIR']																		# if no dir is given, it is equal to "cd ~"				'ls',						# ls [filter]				-> prints the content of the current directory.																		# If filter is given, prints all the files/dirs corresponding to the unix-like filter				'stop-all',					# stop-all 					-> empties the list of tasks to send (use case: an infinite loop fills th task list)				'resend-last',				# resend-last 				-> resend last command that was sent (includes sub-commands)				'send-command-from-dict',	# send-command-from-dict i	-> send the command from the command history with index i				'corrupt-command',			# corrupt-command			-> {NOT IMPLEMENTED} command to send when some received data has been corrupted (could do differently, more deep in the mode ;-))				'send-msg',					# send-msg msg 				-> send a message msg to B				'send-raw',					# send-raw b 				-> send b (encodes it to bytes) as it is to B				'set',						# set key value 			-> ENV_VARS[key] = int(value)				'exit',						# exit 						-> exit the program (using strength !)				'help'						# help						-> show this help message			]'''TAGS:	<COMMAND >	<MESSAGE >	<EXIT>	<STOP>	<custom-tags...> (e.g. MOUSE-POS, MOUSE-PRESS)'''r'''file_path = r'C:\Users\Nicolas\AppData\Local\Google\Chrome\User Data\Default\History'bdb = open(file_path, 'rb').read()open('dbcopy', 'wb').write(bdb)conn = sqlite3.connect('dbcopy')cursor = conn.cursor()'''def send_raw(s):	file = open(FILE_OUT_PATH, 'a')	file.write(s)	file.close()def send_out(msg, tag): # send a msg through the OUT_FILE	if tag:		s = '<{} {}>'.format(tag, msg)	else:		s = msg	send_raw(s)def run(command, client_f, additional_data={'sub-command': False}): # run a command (human||machine)	'''	run(command, client_f, additional_data={}) -> None	gets a command, runs it (arbitrarily)	commands are meant to be run from the user and/or machine.	the commands may be doing stuff that is not implied in the name.	I'm sorry, but this is way too exiting to write correct code (for now, will come sometime)	'''	global ENV_VARS	global COMMAND_DICT	COMMAND_DICT['raw-run'].append(command)	if not 'sub-command' in list(additional_data.keys()):		additional_data['sub-command'] = False	elif not additional_data['sub-command']:		COMMAND_DICT['raw-run-user'] = command	command = command.split(' ')	# PRECOMMANDS:	if command[0].startswith('sync'):		TEMP_DIR = os.getcwd()		os.chdir(ENV_VARS['ROOT DIR'])	else:		TEMP_DIR = None	if ENV_VARS['SHELL VERSION'] == 1 and ENV_VARS['VERBOSE']:		vprint('running command: {}'.format(command[0]))	if command[0] == 'help':		vprint('Commands:\n - {}'.format('\n - '.join(command_list)))	elif command[0] == 'exit':		return	elif command[0] == 'set':		key = ' '.join(command[1:-1])		value = command[-1]		ENV_VARS[key] = int(value)	elif command[0] == 'send-msg':		msg = ' '.join(command[1:])		client_f(msg, 'MESSAGE')	elif command[0] == 'send-raw':		msg = ' '.join(command[1:])		client_f(msg, '')	elif command[0] == 'send-command-from-dict':		key = command[1]		index = int(command[2])		old_command = COMMAND_DICT[key][index-1] # index-1 bc the last command is 'send-command-from-dict' (this one, added just before)		print('old command', old_command)		return		client_f(old_command, 'COMMAND')	elif command[0] == 'resend-last':		additional_data['sub-command'] = True		run('send-command-from-dict raw-run -1', client_f, additional_data=additional_data)	elif command[0] == 'corrupt-command':		raise_error(NotImplementedError, 'corrupt-command has not been implemented.\n Thinking about some bit-concatenation right now?')	elif command[0] == 'stop-all':		global client_stop_function		client_stop_function()	elif command[0] == 'shell-mode':		print('COMMAND NOT WORKING! EXITING.')		return		print('Warning: When changing directory, please use this format: "cd path-to-dir" (only component of the command).')		TEMP_DIR = os.getcwd()		if len(command) > 1:			if command[1] == 'cmd':				shell_mode_format = lambda s: s			elif command[1] == 'bash':				shell_mode_format = lambda s: 'bash -c "{}"'.format(s.replace('"', '\\"'))			shell_mode_name = '({}) '.format(command[1])		else:			shell_mode_format = lambda s: s			shell_mode_name = ''		shellcommand = ''		while True:			shellcommand = input('SHELL üêö {}{} $ '.format(shell_mode_name, os.getcwd()))			print('command: {}'.format(shellcommand))			additional_data['sub-command'] = True			run('cmd ' + shellcommand, client_f=client_f, additional_data=additional_data)			if shellcommand == 'exit':				break			else:				continue			if 'cd' in shellcommand:				index = shellcommand.index('cd')				path = shellcommand[index+3:]				if path.count('"') == 2:					double_quotes_index1 = path.index('"')					double_quotes_index2 = path.index('"', double_quotes_index1+1)					path = path[double_quotes_index1+1:double_quotes_index2]				os.chdir(path)			if shellcommand:				shellcommand = 'cd "{}" '.format(os.getcwd() if shell_mode_name != 'bash' else os.getcwd().replace('\\', '/')) + shellcommand				additional_data['sub-command'] = True				run('cmd {}'.format(shell_mode_format(shellcommand)), client_f=client_f, additional_data=additional_data)	elif command[0] == 'ls':		# if only: ls		if len(command) == 1:			path_list = os.listdir()		else: # else, apply unix-like filter			path_list = glob(' '.join(command[1:]))		# output the files, if there are any		if path_list:			print(' - ' + '\n - '.join(path_list))		else:			print(' nothing here...')	elif command[0] == 'cd':		if len(command) == 1:			path = ENV_VARS['ROOT DIR']		else:			path = ' '.join(command[1:])			path = path.replace('~', ENV_VARS['ROOT DIR'])		if os.path.isdir(path):			os.chdir(path)		else:			raise_error(FileNotFoundError, 'Directory does not exist.')	elif command[0] == 'run':		command = ' '.join(command[1:])		client_f(command, 'COMMAND')	elif command[0] == 'open-tab':		url = ' '.join(command[1:])		if os.path.isfile('C:/Program Files (x86)/Google/Chrome/Application/chrome.exe'):			webbrowser.get('C:/Program Files (x86)/Google/Chrome/Application/chrome.exe %s').open(url,new=2)		elif os.path.isfile('C:/Program Files/Google/Chrome/Application/chrome.exe'):			webbrowser.get('C:/Program Files/Google/Chrome/Application/chrome.exe %s').open(url,new=2)		else:			raise_error(OSError, 'Program Chrome has not been found.')	elif command[0] == 'sync-chrome': # sync own chrome tabs to other		output = os.popen('brotab list').read()		l = list(filter(None, output.split('\n')))		l = [s.split('\t')[-1] for s in l]		for url in l:			client_f('open-tab {}'.format(url), 'COMMAND')	elif command[0] == 'verb':		if len(command) == 1:			print('Verbose Val: {}'.format(ENV_VARS['VERBOSE']))		else:			ENV_VARS['VERBOSE'] = int(command[1])			print('Set verbose to {}'.format(ENV_VARS['VERBOSE'])) # print anyway			if ENV_VARS['SHELL VERSION'] == 2:				additional_data['inter'].VERBOSE = ENV_VARS['VERBOSE']				if 'arachnoid' in list(additional_data.keys()):					additional_data['arachnoid'].verbose = ENV_VARS['VERBOSE']	elif command[0] == 'ping':		client_f('ping ?', 'MESSAGE')		client_f('ping-resp', 'COMMAND')	elif command[0] == 'ping-resp':		vprint('ping received')		client_f('ping received', 'MESSAGE')	elif command[0] in ['cls', 'clear']:		os.system('cls')		print('PID: {}'.format(os.getpid()))	elif command[0] == 'shutdown':		client_f('shutdown-self', 'COMMAND')		time.sleep(1)		os.system('taskkill /f /pid {}'.format(os.getpid()))	elif command[0] == 'shutdown-self':		os.system('taskkill /f /pid {}'.format(os.getpid()))		sys.exit('Shutdown.')	elif command[0] == 'sync':		for file in ENV_VARS['CORE FILES']:			additional_data['sub-command'] = True			run('sendfile {}'.format(file), client_f=client_f, additional_data=additional_data)			time.sleep(ENV_VARS['DF WAIT TIME']/1000)	elif command[0] == 'synci':		additional_data['sub-command'] = True		run('sendfile interpreter.py', client_f=client_f, additional_data=additional_data)		time.sleep(1)		run('restart', client_f=client_f, additional_data=additional_data)	elif command[0] == 'sync+': # sync + restart		additional_data['sub-command'] = True		run('sync', client_f=client_f, additional_data=additional_data)		run('restart', client_f=client_f, additional_data=additional_data)	elif command[0] == 'restart':		client_f('restart', 'COMMAND')		if ENV_VARS['SHELL VERSION'] == 1:			if sys.argv[-1] == 'shell':				os.system('echo Restarting & python interpreter.py shell')			else:				os.system('echo Restarting & python interpreter.py')			sys.exit()		elif ENV_VARS['SHELL VERSION'] == 2:			os.system('echo Restarting Shell v2 & python "custom shell client.py"')			os.system('taskkill /f /pid {}'.format(os.getpid()))			sys.exit()		else:			raise_error(ValueError, 'Unkown Shell Version: {}'.format(ENV_VARS['SHELL VERSION']))		'''		try:			p = psutil.Process(os.getpid())			for handler in p.open_files() + p.connections():				try: os.close(handler.fd)				except IOError as e: vprint('IOError: {}'.format(e))		except Exception as e:			print('Error: {}'.format(e))		python = sys.executable		os.execl(python, python, *sys.argv)		'''	elif command[0] == 'cmd':		client_f('cmdrun cd {} & {}'.format(os.getcwd(), ' '.join(command[1:])), 'COMMAND')	elif command[0] == 'cmdrun':		#proc = subprocess.Popen(command[1:], stdout=subprocess.PIPE, shell=True)		#output = proc.communicate()		output = subprocess.getoutput(' '.join(command[1:]))		vprint('output:\n{}\n'.format(output))		client_f(output, 'MESSAGE')	elif command[0] == 'writefile':		'''		write a file, assuming it is smaller than 5 kb		'''		command = ' '.join(command[1:])		command = command.replace('\\', '\\\\')		try:			file_data = json.loads(command)		except Exception as e:			print('JSON Exception: {}'.format(e))			print('command:', command)			return		transaction_id	=	file_data['transaction id']		index			=	file_data['index']		path 			=	file_data['path'].replace('\\\\', '\\')		opening_mode	=	file_data['opening mode'] # it is assumed there will never be any backslash "\" in the opening mode.		b64file_content =	file_data['content'][2:-1] # removing "b'" and "'" (from "b'these are bytes'")		file_content 	=	base64.b64decode(b64file_content)		file_has_ended	=	bool(int(file_data['end'])) # 0 or 1		if transaction_id not in list(COMMAND_DICT['writefile-hist'].keys()):			COMMAND_DICT['writefile-hist'][transaction_id] = {}			vprint('Writing file with id: {}'.format(transaction_id))		COMMAND_DICT['writefile-hist'][transaction_id][index] = (b64file_content[:25], b64file_content[-25:]) # index is a str, key to a dict.		file = open(path, opening_mode)		file.write(file_content)		file.close()		if file_has_ended:			vprint('Wrote file with id: {}'.format(transaction_id))			client_f('file (transaction id: {}) written.'.format(transaction_id), 'MESSAGE')	elif command[0] == 'sendfile':		'''		send a ~large~ file (5 kb +)		'''		path = ' '.join(command[1:])		if path[1] != ':': # not a absolute windows path			path = os.path.join(os.getcwd(), path)		path = os.path.abspath(path)		if not os.path.isfile(path):			raise_error(FileNotFoundError, 'File not found: {}'.format(path))		transaction_id = ''.join([choice(alphabet) for _ in range(10)])		file_content = open(path, 'rb').read()		file_buffer_list = []		additional_data_length = 57 + len(path.encode('utf8')) + 1 + 256		file_size = len(file_content)		b64_file_size = 4 * file_size / 3 + (4 - (file_size % 4))		b64_file_buffer_size = (ENV_VARS['MAX BUFFER SIZE'] - additional_data_length)		file_buffer_size = int(file_size / (b64_file_size / b64_file_buffer_size))		for buffer_start_index in range(0, file_size, file_buffer_size):			encoded_b64_data = base64.b64encode(file_content[buffer_start_index : buffer_start_index + file_buffer_size])			assert len(encoded_b64_data) < ENV_VARS['MAX BUFFER SIZE'] + additional_data_length			file_buffer_list.append(encoded_b64_data)		last_index = len(file_buffer_list) - 1 # for "end" key in json		for index, file_buffer in enumerate(file_buffer_list):			if index > 0:				time.sleep(ENV_VARS['DF WAIT TIME'] / 1000)			sub_command = r'writefile {"transaction id": "%s", "index": "%s", "path": "%s", "opening mode": "%s", "content": "%s", "end": "%s"}' % (								transaction_id,								str(index),								path,								'wb' if index == 0 else 'ab',								file_buffer,								'1' if index == last_index else '0'				)			vprint('size of sub_command: {}'.format(len(sub_command)))			client_f(sub_command, 'COMMAND')		if index > 10:			print('Sent (big?) file {}'.format(path)) # print anyway	elif command[0] == 'sendfiles':		s = ' '.join(command[1:])		if not '"' in s:			path_list = glob(s)		else:			path_list = paths_from_string(s + ' ') # need the ' ' for list[i:j+1 <- the "+1" can go outside the bounds ;-) ]		additional_data['sub-command'] = True		for path in path_list:			run('sendfile {}'.format(path), client_f=client_f, additional_data=additional_data)			time.sleep(ENV_VARS['DF WAIT TIME']/1000)	elif command[0] == 'getfile':		path = ' '.join(command[1:])		path = os.path.abspath(path)		client_f('sendfile {}'.format(path), 'COMMAND')	elif command[0] == 'getfiles':		s = ' '.join(command[1:])		path_list = paths_from_string(s)		vprint('l', path_list)		additional_data['sub-command'] = True		for path in path_list:			run('getfile {}'.format(path), client_f=client_f, additional_data=additional_data)			time.sleep(ENV_VARS['DF WAIT TIME']/1000)	else:		COMMAND_DICT['raw-run'].pop(-1)		raise_error(print, 'ERROR: Command {} not found.'.format(command[0]), do_raise=False)	# POST-COMMAND	if TEMP_DIR:		os.chdir(TEMP_DIR)def format_string_buffer(s):	replacements = {					'\n': '\\n',					'\\': '\\\\',					'\'': '\\\'',					'\a': '\\a',					'\b': '\\b',					'\f': '\\f',					'\n': '\\n',					'\r': '\\r',					'\t': '\\t',					'\v': '\\v'				   }	for key, item in list(replacements.items()):		s = s.replace(key, item)	return sdef format_buffer(buffer_):	replacements = {					b'\n': b'\\n',					b'\\': b'\\\\',					b'\'': b'\\\'',					b'\a': b'\\a',					b'\b': b'\\b',					b'\f': b'\\f',					b'\n': b'\\n',					b'\r': b'\\r',					b'\t': b'\\t',					b'\v': b'\\v'				   }	for key, item in list(replacements.items()):		buffer_ = buffer_.replace(key, item)	return buffer_def format_command(command):	command = ' '.join(filter(None, command.split(' '))) # remove unneeded spaces	return commanddef handler(content, client_f, ignores=[], additional_data={'sub-command': False}):	global ENV_VARS	if ENV_VARS['INTERPRETER VERSION'] == 1:		content_list = list(filter(None, content.split('<<RECV>>')))		content_list = list(map(lambda c: c[:-1] if c[-1] == '\n' else c, content_list))	else:		content_list = [content]	for msg in content_list:		if ENV_VARS['INTERPRETER VERSION'] == 1:			msg = msg[msg.index(': ') + 2:]		tag = msg[1:-1].split(' ')[0]		if tag in ('EXIT', 'STOP'):			break		elif tag == 'COMMAND':			command = ' '.join(msg[1:-1].split(' ')[1:])			if command.split(' ')[0] in ignores:				vprint('ignored command: {}'.format(command.split(' ')[0]))				return			run(command, client_f=client_f, additional_data=additional_data)		elif tag == 'MESSAGE':			text = ' '.join(msg[1:-1].split(' ')[1:])			print('message: {}'.format(text))		elif tag != '><':			raise_error(print, 'ERROR: unkown tag "{}"'.format(tag), do_raise=False)		# else: pass # in case tag == '><'def interpreter(file_path=FILE_IN_PATH, announce=True, ignores=[]):	global ENV_VARS	ENV_VARS['INTERPRETER VERSION'] = 1	ENV_VARS['SHELL VERSION'] = 1	file = open(file_path, 'r')	content = file.read()	content = ''	if announce: vprint('Interpreter: Loop started')	while content != '<STOP>':		if content:			handler(content, send_out, ignores=ignores)		content = file.read()	sys.exit('received <STOP> in interpreter')def interpreter2(server, additional_data, announce=True, ignores=[]):	global ENV_VARS	ENV_VARS['INTERPRETER VERSION'] = 2	ENV_VARS['SHELL VERSION'] = 2	def custom_send_out(msg, tag):		if tag:			s = '<{} {}>'.format(tag, msg)		else:			s = msg		s = s.encode('utf8')		if tag == 'COMMAND':			COMMAND_DICT['raw-out'].append(msg)		server.out_tasks.append(s)	if announce: vprint('Interpreter: Loop started')	content = ''	while content != '<STOP>':		if server.in_tasks:			content = server.in_tasks.pop(0)			content = content.decode('utf8')			#print('\n\n\nCONTENT', content, '\n\n\n')			if content:				handler(content, custom_send_out, ignores=ignores, additional_data=additional_data)	sys.exit('received <STOP> in interpreter v2')def paths_from_string(s):	num_paths = s.count('"')	assert num_paths % 2 == 0 # there are an even number of '"' signs	path_list = []	for i in range(num_paths//2):		index1 = s.index('"')		index2 = s.index('"', index1+1)		path_list.append(s[index1+1:index2])		s = s[index2+1:]	return path_listdef message_printer(file_path=FILE_IN_PATH):	global ENV_VARS	file_handler = open(file_path)	while ENV_VARS['IN SHELL']:		content = file_handler.read()		if content:			if '<MESSAGE' in content:				msg = content[content.index('<MESSAGE')+9:-1]				print('MSG: {}'.format(msg))def shell2(client, inter): # client -> arachnoid.Spider, inter -> interpreter.py (module)	global ENV_VARS	global COMMAND_DICT	ENV_VARS['IN SHELL'] = True	ENV_VARS['SHELL VERSION'] = 2	def custom_send_out(msg, tag):		if tag:			s = '<{} {}>'.format(tag, msg)		else:			s = msg		s = s.encode('utf8')		if tag == 'COMMAND':			COMMAND_DICT['raw-out'].append(msg)		client.tasks.append(s)	if client._connected:		print('Spider üï∑Ô∏è Connected.')	command = ''	while command != 'exit':		try:			raw_command = input(' ü¶ã ' + os.getcwd() + ' # ')			command = format_command(raw_command)		except KeyboardInterrupt:			print('^C')			continue		except Exception as e:			print('ERROR (during command input): {}'.format(e))		if command:			try:				run(command, additional_data={'inter': inter, 'arachnoid': client}, client_f=custom_send_out)				time.sleep(.1)			except Exception as e:				raise_error(lambda s: print('ERROR: ' + s), str(e), do_raise=False)				traceback.print_exc()	ENV_VARS['IN SHELL'] = False	client.close()def raise_error(error_type, error_message, do_raise=True):	if do_raise:		raise error_type(' üî¨ ' + error_message)	else:		error_type(' üî¨ ' + error_message)if __name__ == '__main__':	arg = sys.argv[-1]	if arg == 'shell':		shell()	else:		if arg.startswith('verb'):			ENV_VARS['VERBOSE'] = int(arg[-1])			print('Set Verbose to : {}'.format(ENV_VARS['VERBOSE']))		interpreter()#???